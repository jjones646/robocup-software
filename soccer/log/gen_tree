#!/usr/bin/python
# -*- coding: utf-8 -*-

from xml.dom.minidom import *
import sys

filename = sys.argv[1]
dom = parse(filename)
root = dom.firstChild

primitives = ['bool', 'float', 'double']

typeMap = {'string': 'std::string'}

# Add int* and uint* to primitives and typeMap
for i in ['8', '16', '32', '64']:
    typename = 'int' + i
    typeMap[typename] = typename + '_t'
    typeMap['u' + typename] = 'u' + typename + '_t'
    primitives.append(typename)
    primitives.append('u' + typename)
	
class Enum:
	def __init__(self):
		self.ctype = None
		
		self.typename = None
		
		self.extType = None
		
		self.parent = None
		
		self.items = {}
		
	def parentType(self):
		if self.extType:
			return ""
		if self.parent:
			return self.parent.type()
			
		return ""
		
	def type(self):
		if self.extType:
			return self.extType
		elif self.parent:
			return self.parent.type() + "::" + self.typename
			
		return "Packet::" + self.typename
		
class Member:
	def __init__(self):
		self.name = None
		self.type = None
		self.size = None
	
class Struct:
	def __init__(self):
		self.members = []
		
		self.typename = ""
		
		self.extType = None
		
		self.structs = []
	
		self.parent = None
		
		self.enums = []
		
		self.externOnly = True
		
		self.arrays = []
		
	def type(self):
		if self.extType:
			return self.extType
		elif self.parent:
			return self.parent.type() + "::" + self.typename
		
		return "Packet::" + self.typename

def procStruct(root, parent = None):
	self = Struct()
	
	self.typename = root.getAttribute("typename")
	self.extType = root.getAttribute("external_cpp")
	self.parent = parent
	
	for node in root.childNodes:
		if node.nodeName == "struct":
			self.structs.append(procStruct(node, self))
		#elif node.nodeName == "member":
			#name = node.getAttribute("name")
			#type = node.getAttribute("type")
			
			#self.externOnly = False
			#self.members[name] = type
		elif node.nodeName == "array" or node.nodeName == "member":
			m = Member()
			m.name = node.getAttribute("name")
			m.type = node.getAttribute("type")
			m.size = node.getAttribute("size")
			
			if node.nodeName == "array" and not m.size:
				m.size = "*"
			
			self.externOnly = False
			self.members.append(m)
			
		elif node.nodeName == "enum":
			enum = Enum()
			enum.typename = node.getAttribute("typename")
			enum.extType = node.getAttribute("external_cpp")
			enum.ctype = node.getAttribute("type")
			enum.parent = self
			
			i = 0
			for e in node.childNodes:
				if e.nodeType != Node.ELEMENT_NODE:
					continue
				n = e.getAttribute("name")
				v = e.getAttribute("value")
				
				if v:
					enum.items[v] = n
				else:
					enum.items[i] = n
					
				i += 1
			
			self.enums.append(enum)
			
	return self
			
rootStruct = procStruct(root)

indentLevel = 0

def indent():
	global indentLevel
	indentLevel += 1
	
def unindent():
	global indentLevel
	indentLevel -= 1
	
def write(str = ''):
	if "}" in str:
		unindent()
		
	print ' ' * (indentLevel * 4) + str
	
	if "{" in str:
		indent()

def makeStruct(struct):
	if struct.externOnly:
		return
	
	for e in struct.enums:
		write("""static inline void handleExt(QStandardItem* c1, QStandardItem* c2, const %s& p, const char* name="%s")""" % (e.type(), e.typename))
		write("{")
		write("""QString s = "";""")
		write("switch (p)")
		write("{")
		for v in e.items:
			write("""case %s::%s:""" % (e.parentType(), e.items[v]))
			write("""\ts = "%s";""" % e.items[v])
			write("\tbreak;")
		write("}")
		write("""c1->setText(name);""");
		write("""c2->setText(s);""");
		write("}\n")

	for s in struct.structs:
		makeStruct(s)
		
	write("""static inline void handleExt(QStandardItem* c1, QStandardItem* c2, const %s& p, const char* name = "%s")""" % (struct.type(), struct.typename))
	write("{")
	
	write("for (int i=c1->rowCount() ; i<%d ; ++i)" % (len(struct.members)))
	write("{")
	write("c1->setChild(i,0, new QStandardItem());")
	write("c1->setChild(i,1, new QStandardItem());")
	write("c1->child(i,0)->setEditable(false);")
	write("c1->child(i,1)->setEditable(false);")
	write("}\n")
	
	write("c1->removeRows(%d, c1->rowCount() - %d);" % (len(struct.members), len(struct.members)))

	c = 0
	for m in struct.members:
		write("""c1->child(%d, 0)->setText("%s");""" % (c, m.name))
		
		if m.size and m.size == "*":
			write("""Log::handleExtArray(c1->child(%d, 0), c1->child(%d, 1), &(p.%s[0]), p.%s.size());""" % (c, c, m.name, m.name))
		elif m.size:
			write("""Log::handleExtArray(c1->child(%d, 0), c1->child(%d, 1), p.%s, %s);""" % (c,c, m.name, m.size))
		else:
			write("""Log::handleExt(c1->child(%d, 0), c1->child(%d, 1), p.%s, "%s");""" % (c, c, m.name, m.name))
		
		c += 1

	write("}\n")


write("#ifndef TREE_GEN_%s_HPP" % rootStruct.typename);
write("#define TREE_GEN_%s_HPP" % rootStruct.typename);

write("#include <log/TreeGen.hpp>");
write("#include <stdint.h>");
write("#include <vector>");
write("#include <string>");

write("namespace Log");
write("{")

makeStruct(rootStruct)

write("}")

write("#endif //TREE_GEN_HPP");
