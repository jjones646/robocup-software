import os.path

Import('*')

# Add the install path so that gcc and newlib can find the tools that we are building
host_env = env_base.Clone()
host_env.AppendENVPath('PATH', Dir('install/bin').abspath)
# Set -jn in the environment instead of on the make command line so if it changes,
# scons won't try to rebuild everything (each target depends on the command used
# to build it).
host_env['ENV']['MAKEFLAGS'] = '-j%d' % GetOption('num_jobs')

# note: eabi = Embedded Application Binary Interface
target = 'arm-elf'

# ARM build environment
arm = host_env.Clone()

install_dir = Dir('install')

# Build packages
def BuildSubmodule(dir, config_options):
	submodule_dir = Dir('#/firmware/%s' % dir)
	build_dir = Dir(dir)
	
	# Configure in the source dir
	# if the config completes successfully, it will create a Makefile
	configure = host_env.Command('%s/Makefile' % build_dir, submodule_dir,
		'cd ${TARGET.dir} && '
		'${SOURCE.abspath}/configure --prefix=%s %s' %
		(install_dir.abspath, config_options))
	Clean(configure, build_dir)

	# Build the package
	build_stamp = build_dir.File('.built')
	build = host_env.Command(build_stamp, '',
		'cd ${TARGET.dir} && '
		'make && '
		'make install && '
		'touch ${TARGET.file}')
	Clean(build, build_dir)
	Depends(build, configure)
	
	return configure, build

#
# In order:
# * build binutils (using host compiler)
# * build arm cross-compiler
# * build newlib using the newly-created cross-compiler
# * build the rest of gcc
#

# GNU binutils
config_binutils, build_binutils = BuildSubmodule('external/binutils',
	'--target=%s --enable-interwork --enable-multilib --disable-werror' % target)

# 
gcc_config_options = ('--target=%s '
	'--with-newlib '	# use newlib instead of the gnu std lib
	'--enable-languages="c" --disable-threads '
	'--disable-shared '
	'--with-headers=%s/source/newlib/libc/include '
	'--enable-interwork '	# allows for assembling Thumb and ARM code mixed into the same binaries
	'--enable-multilib '
	'--with-system-zlib '
	'--disable-libunwind-exceptions' %
	(target, Dir('.').abspath))


gcc_build_dir = Dir('%s' % 'external/gcc')
gcc_submodule_dir = Dir('#/firmware/external/gcc')


# Configure in the source dir
# if the config completes successfully, it will create a Makefile
config_gcc = host_env.Command('%s/Makefile' % gcc_build_dir, gcc_submodule_dir,
	'cd ${TARGET.dir} && '
	'${SOURCE.abspath}/configure --prefix=%s %s' % (install_dir.abspath, gcc_config_options))
Clean(config_gcc, gcc_build_dir)

# build binutils before building gcc compiler
Depends(config_gcc, build_binutils)

# Build the gcc compiler
gcc_build_stamp = gcc_build_dir.File('.built-compiler')
compile_gcc_compiler = host_env.Command(gcc_build_stamp, '',
	'cd ${TARGET.dir} && '
	'make all-gcc install-gcc && '
	'touch ${TARGET.file}')
Clean(compile_gcc_compiler, gcc_build_dir)
Depends(compile_gcc_compiler, config_gcc)

# for some reason, Scons looks for a compiler ending in -cc, while the build process
# actually names it ending in -gcc, so we symlink it
# symlink gcc to the right name
gcc_orig_name = '%s-gcc' % target
symlink_gcc_compiler = host_env.Command(Dir('install/bin').File('%s-cc' % target), '',
	'cd ${TARGET.dir} && '
	'ln -sf ./%s %s-cc' %
	(gcc_orig_name, target))
Depends(symlink_gcc_compiler, compile_gcc_compiler)

# symlink elf objcopy to the right name
# symlink_elf_objcopy = host_env.Command(install_dir.File('bin/arm-elf-objcopy'), '',
# 	'cd ${TARGET.dir} && '
# 	'ln -sf ./%s-objcopy arm-elf-objcopy' %
# 	target)
# Depends(symlink_elf_objcopy, compile_gcc_compiler)

# newlib
config_newlib, build_newlib = BuildSubmodule('external/newlib',
	'--target %s --enable-interwork --enable-multilib --enable-newlib-hw-fp' % target)
Depends(build_newlib, symlink_gcc_compiler)
# Depends(build_newlib, symlink_elf_objcopy)

# build the rest of gcc
build_gcc_all = host_env.Command(gcc_build_dir.File('.built-all'), '', 
	'cd ${TARGET.dir} && '
	'make all install && '
	'touch ${TARGET.file}')
Depends(build_gcc_all, build_newlib)


# Aliases to allow specific parts of the toolchain to be rebuilt/cleaned
Alias('arm-binutils', build_binutils)
Alias('arm-newlib', build_newlib)
Alias('arm-gcc', [symlink_gcc_compiler, build_gcc_all])
Alias('arm-toolchain', ['arm-binutils', 'arm-newlib', 'arm-gcc'])

# To remove the installed files, you must clean all of the toolchain.
# The packages do not provide any way to uninstall files.
Clean('arm-toolchain', Dir('install'))


arm.Append(BUILDERS={'Binary': Builder(
	action='arm-elf-objcopy -O binary $SOURCE $TARGET',
	suffix='.bin',
	src_suffix='.elf')})

# Add a dependency on the complete toolchain to every object
def ArmEmitter(target, source, env):
	for s in source:
		env.Depends(s, 'arm-toolchain')
	return (target, source)
if not GetOption('clean'):
	# Doing this all the time causes the toolchain to be cleaned whenever a target built with it is cleaned.
	#
	# We are subverting scons' automatic cleaning: build the toolchain when building targets that need it,
	# but only clean it if explicitly instructed to do so on the command line.
	arm.AppendUnique(PROGEMITTER=ArmEmitter)
	arm.AppendUnique(LIBEMITTER=ArmEmitter)

Export('arm')
