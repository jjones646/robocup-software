import os.path

Import('*')

# Add the install path so that gcc and newlib can find the tools that we are building
host_env = env_base.Clone()
host_env.AppendENVPath('PATH', Dir('install/bin').abspath)
# Set -jn in the environment instead of on the make command line so if it changes,
# scons won't try to rebuild everything (each target depends on the command used
# to build it).
host_env['ENV']['MAKEFLAGS'] = '-j%d' % GetOption('num_jobs')

# mirror_gnu = 'http://www.gtlib.gatech.edu/pub/gnu/gnu'
# mirror_newlib = 'ftp://sources.redhat.com/pub/newlib'

# Package versions and size of complete file
# Use gcc-core to avoid downloading huge things when we're not using C++
# binutils_package = 'binutils-2.21'
# binutils_size = 18742991
# gcc_version = '4.5.2'
# gcc_package = 'gcc-' + gcc_version
# gcc_size = 28241468

# newlib_package = 'newlib-2.0.0'
# newlib_size = 15868470

# downloads_dir = Dir('#/downloads')

# binutils_file = '%s.tar.bz2' % binutils_package
# binutils_url = '%s/binutils/%s' % (mirror_gnu, binutils_file)

# gcc_file = 'gcc-core-%s.tar.bz2' % gcc_version
# gcc_dir = 'gcc-' + gcc_version
# gcc_url = '%s/gcc/%s/%s' % (mirror_gnu, gcc_dir, gcc_file)

# newlib_file = '%s.tar.gz' % newlib_package
# newlib_url = '%s/%s' % (mirror_newlib, newlib_file)

target = 'arm-eabi'

# Build packages
def BuildSubmodule(dir, config_options):

	# if os.path.isfile(dl_target.abspath) and os.path.getsize(dl_target.abspath) == size:
		# File is already present and complete
	# dl_file = dl_target
	# else:
		# Need to download file
		# dl_file = host_env.Command(dl_target, '', 'curl %s -o ${TARGET}' % url)

	submodule_dir = Dir('#/firmware/%s' % dir)
	build_dir = Dir('%s' % dir)
	# mkdir_build_dir = host_env.Command(build_dir, submodule_dir, 'mkdir -p ${TARGET}')
	# Clean(mkdir_build_dir, build_dir)

	# source_dir = Dir('external/%s' % dir)
	# build_dir = Dir('build/%s' % dir)

	# These files will be created after complicated steps are completed successfully
	# config_stamp = build_dir.File('.configured')
	
	# Unpack the source
	# unpack = host_env.Command(source_dir.File('.unpacked'), dl_file,
		# 'tar -C %s -xf ${SOURCE} && touch ${TARGET}' % Dir('source').abspath)
	# Depends(unpack, dl_file)
	# Clean(unpack, source_dir)
	
	# Configure in the source dir
	# if the config completes successfully, it will create a Makefile
	configure = host_env.Command('%s/Makefile' % build_dir, submodule_dir,
		'cd ${TARGET.dir} && ${SOURCE.abspath}/configure --prefix=%s %s' % (Dir('install').abspath, config_options))
	# Depends(configure, mkdir_build_dir)
	# Clean(configure, '%/*' % build_dir)	#FIXME: uncomment, use Glob

	# Build the package
	build_stamp = build_dir.File('.built')
	build = host_env.Command(build_stamp, '', 'cd ${TARGET.dir} && make && make install && touch ${TARGET.file}')
	Clean(build, build_dir)
	Depends(build, configure)
	
	return build


arm_binutils = BuildSubmodule('external/binutils',
	'--target=%s --enable-interwork --enable-multilib --disable-werror' % target)

arm_gcc = BuildSubmodule('external/gcc',
	'--target=%s --with-newlib --enable-languages="c" --disable-threads '
	'--disable-shared --with-headers=%s/source/newlib/libc/include'
	'--enable-interwork --enable-multilib --with-system-zlib --with-mode=thumb --with-arch=armv4t' %
	(target, Dir('.').abspath))

# (unpack_gcc, config_gcc, build_gcc) = BuildPackage(gcc_dir, gcc_file, gcc_size, gcc_url,
# 	'--target=%s --with-newlib --enable-languages="c" --disable-threads '
# 	'--disable-shared --with-headers=%s/source/%s/newlib/libc/include '
# 	'--enable-interwork --enable-multilib --with-system-zlib --with-mode=thumb --with-arch=armv4t' %
# 	(target, Dir('.').abspath, newlib_package))



arm_newlib = BuildSubmodule('external/newlib',
	'--target=%s --enable-interwork --enable-multilib --enable-newlib-hw-fp' % target)


# Aliases to allow specific parts of the toolchain to be rebuilt/cleaned
Alias('arm-binutils', arm_binutils)
Alias('arm-newlib', arm_newlib)
Alias('arm-gcc', arm_gcc)
Alias('arm-toolchain', ['arm-binutils', 'arm-gcc', 'arm-newlib'])

# Help('  arm-toolchain: ARM %s, %s, and %s\n' % (binutils_package, gcc_package, newlib_package))

# To remove the installed files, you must clean all of the toolchain.
# The packages do not provide any way to uninstall files.
Clean('arm-toolchain', Dir('install'))

# ARM build environment
arm = host_env.Clone()
arm.Replace(CC='arm-elf-gcc')

arm.Append(BUILDERS={'Binary': Builder(
	action='arm-elf-objcopy -O binary $SOURCE $TARGET',
	suffix='.bin',
	src_suffix='.elf')})

# Add a dependency on the complete toolchain to every object
def ArmEmitter(target, source, env):
	for s in source:
		env.Depends(s, 'arm-toolchain')
	return (target, source)
if not GetOption('clean'):
	# Doing this all the time causes the toolchain to be cleaned whenever a target built with it is cleaned.
	#
	# We are subverting scons' automatic cleaning: build the toolchain when building targets that need it,
	# but only clean it if explicitly instructed to do so on the command line.
	arm.AppendUnique(PROGEMITTER=ArmEmitter)
	arm.AppendUnique(LIBEMITTER=ArmEmitter)

Export('arm')
