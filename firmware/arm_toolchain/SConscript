Import('*')

mirror_gnu = 'http://www.gtlib.gatech.edu/pub/gnu/gnu'
mirror_newlib = 'ftp://sources.redhat.com/pub/newlib'

# Package versions
# Use gcc-core to avoid downloading huge things when we're not using C++
binutils_package = 'binutils-2.21'
gcc_version = '4.5.2'
newlib_package = 'newlib-1.19.0'

downloads_dir = Dir('#/downloads')

binutils_file = '%s.tar.bz2' % binutils_package
binutils_url = '%s/binutils/%s' % (mirror_gnu, binutils_file)

gcc_file = 'gcc-core-%s.tar.bz2' % gcc_version
gcc_dir = 'gcc-' + gcc_version
gcc_url = '%s/gcc/%s/%s' % (mirror_gnu, gcc_dir, gcc_file)

newlib_file = '%s.tar.gz' % newlib_package
newlib_url = '%s/%s' % (mirror_newlib, newlib_file)

target = 'arm-elf'

# Build packages
def BuildPackage(dir, filename, url, config_options):
	dl_target = downloads_dir.File(filename)
	done_stamp = downloads_dir.File('.done_' + filename)
	(dl_file, dl_done) = env.Command([dl_target, done_stamp], '',
		'curl %s -o ${TARGETS[0]} && touch ${TARGETS[1]}' % url)
	NoClean(dl_file)
	NoClean(dl_done)
	
	source_dir = Dir('source/%s' % dir)
	build_dir = Dir('build/%s' % dir)

	# These files will be created after complicated steps are completed successfully
	config_stamp = build_dir.File('.configured')
	build_stamp = build_dir.File('.built')
	
	# Unpack the source
	unpack = env.Command(source_dir.File('.unpacked'), dl_file,
		'tar -C %s -xf ${SOURCE} && touch ${TARGET}' % Dir('source').abspath)
	Depends(unpack, dl_done)
	Clean(unpack, source_dir)
	
	# Configure in a build directory
	configure = env.Command(config_stamp, source_dir,
		'cd ${TARGET.dir} && ${SOURCE.abspath}/configure --prefix=%s %s && touch ${TARGET.file}' % (Dir('install').abspath, config_options))
	
	# Build the package
	build = env.Command(build_stamp, config_stamp, 'cd ${TARGET.dir} && make -j%d && make install && touch ${TARGET.file}' % GetOption('num_jobs'))
	Clean(build, build_dir)
	
	return (unpack, configure, build)

(unpack_binutils, config_binutils, build_binutils) = BuildPackage(binutils_package, binutils_file, binutils_url,
	'--target=%s --enable-interwork --enable-multilib' % target)

(unpack_gcc, config_gcc, build_gcc) = BuildPackage(gcc_dir, gcc_file, gcc_url,
	'--target=%s --with-newlib --enable-languages="c" --disable-threads '
	'--disable-shared --with-headers=%s/source/%s/newlib/libc/include '
	'--enable-interwork --enable-multilib --with-system-zlib --with-mode=thumb --with-arch=armv4t' %
	(target, Dir('.').abspath, newlib_package))

(unpack_newlib, config_newlib, build_newlib) = BuildPackage(newlib_package, newlib_file, newlib_url,
	'--target=%s --enable-interwork --enable-multilib' % target)

# Dependencies
Depends(config_gcc, unpack_newlib)
Depends(config_gcc, build_binutils)
Depends(config_newlib, build_gcc)

# Aliases to allow specific parts of the toolchain to be rebuilt/cleaned
Alias('arm-binutils', (unpack_binutils, config_binutils, build_binutils))
Alias('arm-gcc', (unpack_gcc, config_gcc, build_gcc))
Alias('arm-newlib', (unpack_newlib, config_newlib, build_newlib))
Alias('arm-toolchain', ['arm-binutils', 'arm-gcc', 'arm-newlib'])

# To remove the installed files, you must clean all of the toolchain.
# The packages do not provide any way to uninstall files.
Clean('arm-toolchain', Dir('install'))

