#!/usr/bin/env python

import sys
import time
from usb import *

debug = False

device = None
for bus in busses():
	for dev in bus.devices:
		if dev.idVendor == 0x3141 and dev.idProduct == 0x0004:
			device = dev.open()
			break
assert device

device.setConfiguration(1)
device.claimInterface(0)

def autoCalibrate(enabled):
	device.controlMsg(ENDPOINT_IN | TYPE_VENDOR, 4, None, enabled, 0)

cc1101_regs = (
    (0x0b, 0x0c),    # FSCTRL1  - Frequency synthesizer control.
    (0x0d, 0x21),    # FREQ2    - Frequency control word, high byte.
    (0x0e, 0x7b),    # FREQ1    - Frequency control word, middle byte.
    (0x0f, 0x42),    # FREQ0    - Frequency control word, low byte.
    (0x10, 0x2d),    # MDMCFG4  - Modem configuration.
    (0x11, 0x2f),    # MDMCFG3  - Modem configuration.
    (0x12, 0x13),    # MDMCFG2  - Modem configuration.
    (0x13, 0x22),    # MDMCFG1  - Modem configuration.
    (0x14, 0xe5),    # MDMCFG0  - Modem configuration.
    (0x0a, 0x00),    # CHANNR   - Channel number.
    (0x15, 0x62),    # DEVIATN  - Modem deviation setting (when FSK modulation is enabled).
    (0x21, 0xb6),    # FREND1   - Front end RX configuration.
    (0x22, 0x10),    # FREND0   - Front end RX configuration.
    (0x18, 0x08),    # MCSM0    - Main Radio Control State Machine configuration.
    (0x17, 0x00),    # MCSM1    - Main Radio Control State Machine configuration.
    (0x19, 0x1d),    # FOCCFG   - Frequency Offset Compensation Configuration.
    (0x1a, 0x1c),    # BSCFG    - Bit synchronization Configuration.
    (0x1b, 0xc7),    # AGCCTRL2 - AGC control.
    (0x1c, 0x00),    # AGCCTRL1 - AGC control.
    (0x1d, 0xb0),    # AGCCTRL0 - AGC control.
    (0x03, 0x0f),    # FIFOTHR  - RXFIFO and TXFIFO thresholds.
    (0x07, 0x4c),    # PKTCTRL1 - Packet automation control.
    (0x08, 0x05),    # PKTCTRL0 - Packet automation control.
    (0x06, 0x3e)     # PKTLEN   - Packet length.
)

def command(value):
	device.controlMsg(ENDPOINT_IN | TYPE_VENDOR, 2, None, 0, value)

def writeRegister(addr, value):
	device.controlMsg(ENDPOINT_IN | TYPE_VENDOR, 1, None, value, addr)

def configure():
	autoCalibrate(False)
	for (addr, value) in cc1101_regs:
		writeRegister(addr, value)
	autoCalibrate(True)

def send(buf):
	device.bulkWrite(1, buf)

def receive():
	try:
		buf = device.bulkRead(2, 64, 50)
	except USBError:
		# Timeout
		return None
	return buf[:-2]

configure()

def abort():
	# Abort OTA
	for i in range(4):
		send([0x00, 0xff])
		time.sleep(0.05)

robots = []
for i in range(4):
	send([0xc9, 0xd5])
	rx = receive()
	if rx and len(rx) == 1:
		robot_id = rx[0]
		if not robot_id in robots:
			robots.append(robot_id)
			print 'Found robot %d' % robot_id
	time.sleep(0.05)

if len(sys.argv) != 2:
	print >> sys.stderr, "Usage: %s <flash_image>" % sys.argv[0]
	abort()
	sys.exit(1)

f = file(sys.argv[1])
data = [ord(x) for x in f.read()]
f.close()

assert robots

offset = 0
Chunk_Size = 32  # Must be a multiple of 4 and a factor of the page size
start = time.time()
ack_count = 0
while offset < len(data):
	if not debug:
		print '\r%3d%%' % (offset * 100 / len(data)),
		sys.stdout.flush()
	
	n = min(Chunk_Size, len(data) - offset)
	packet = [0x39, offset & 0xff, (offset >> 8) & 0xff, (offset >> 16) & 0xff] + data[offset:offset + n]
	
	if ack_count < 4 and False:
		# Send without acknowledgement
		if debug:
			print len(packet), packet
		send(packet)
		offset += Chunk_Size
		ack_count += 1
	else:
		# Send and wait for acknowledgements
		packet[0] |= 1
		ack_count = 0
		ok = [False] * 16
		num_ok = 0
		acked = False
		for tries in range(5):
			if debug:
				print len(packet), packet
			send(packet)
			while num_ok < len(robots):
				rx = receive()
				if not rx:
					# Timeout: at least one robot failed to respond
					break
				robot_id = rx[0] & 15
				status = rx[0] >> 4
				assert status == 0 or status == 8
				if (status == 0 or status == 8) and not ok[robot_id]:
					ok[robot_id] = True
					num_ok += 1
			if num_ok == len(robots):
				acked = True
				break
			if debug:
				print 'Attempt %d failed' % tries
		if not acked:
			print 'Tried too many times'
			for i in robots:
				if not ok[i]:
					print '  Robot %d did not respond' % i
			abort()
			sys.exit(1)
		offset += Chunk_Size
end = time.time()
print '\rDone'
print '%f bytes/s' % (float(len(data)) / (end - start))

# Finish
n = len(data)
packet = [0x6b, n & 0xff, (n >> 8) & 0xff, (n >> 16) & 0xff]
num_ok = 0
ok = [False] * 16
for i in range(4):
	send(packet)
	rx = receive()
	if rx:
		robot_id = rx[0] & 15
		status = rx[0] >> 4
		assert status == 0
		if status == 0 and not ok[robot_id]:
			ok[robot_id] = True
			num_ok += 1
assert num_ok == len(robots)
